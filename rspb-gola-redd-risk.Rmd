---
title: "REDD+ Feasability Assessment"
subtitle: "Potential activity data and forest area estimates for Liberia and the RSPB Gola project area"
date: "2024-12-23"
output: 
  html_document:
    toc: TRUE
    toc_float:
      collapsed: FALSE    
    toc_depth: 4
    df_print: kable
    pandoc_args: "--highlight=tango"

always_allow_html: TRUE
bibliography: references.bib
---

```{r, echo=F, message=F, warning=F, error=F, comment=NA}
readRenviron("~/.Renviron")
#readRenviron("~/.Rprofile")
#{bash}: "source  ~/.zshrc"

options(repos = c(CRAN = "https://cloud.r-project.org"))

#libs = c(
#  "basemaps", "c2z", "cpp11", "cpp11armadillo", "cpp11eigen", "cols4all", 
#  "earthdatalogin", "elevatr", "geodata", "ggmap", "htmltools", "janitor", 
#  "jsonlite", "kableExtra", "knitr", "latex2exp", "leaflet", 
#  "leaflet.providers", "lwgeom", "magrittr", "maptiles", "MASS", 
#  "methods", "osmdata", "pander", "psych", "raster", 
#  "rasterVis", "RColorBrewer", "Rcpp", "Rcpp11", "raster", "readxl", 
#  "rmarkdown", "rnaturalearth", "rnaturalearthdata", "RStoolbox", 
#  "s2", "sf", "sits", "sp",
#  "stars", "stringr", "terra", "terrainr", "tibble", "tidyr", "tidyverse", 
#  "tinytex", "tmap", "tmaptools", "torch", "units"
#  )

#remotes::install_github("r-spatial/sf", configure.args = c(
#  "--with-gdal-config=/opt/local/bin/gdal-config", 
#  "--with-proj-include=/opt/local/lib/proj9/include", 
#  "--with-proj-lib=/opt/local/lib/proj9/lib", 
#  "--with-geos-config=/opt/local/bin/geos-config"))

#install.packages('terra', type="source", configure.args = c(
#  "--with-gdal-config=/opt/local/bin/gdal-config", 
#  "--with-proj-include=/opt/local/lib/proj9/include", 
#  "--with-proj-lib=/opt/local/lib/proj9/lib", 
#  "--with-geos-config=/opt/local/bin/geos-config"))

#installed_libs = libs %in% rownames(installed.packages())
#if(any(installed_libs==F)){install.packages(libs[!installed_libs],repos="https://cloud.r-project.org")}
#invisible(lapply(libs, library, character.only = T))
#lapply(libs, require, character.only = T)

#linux installation paths
#install.packages("sf",type = "source",configure.args = c(
#    "--with-gdal-config=/usr/bin/gdal-config",
#    "--with-geos-config=/usr/bin/geos-config",
#    "--with-proj-include=/usr/include",
#    "--with-proj-lib=/usr/lib64"))

#install.packages("terra",type = "source",configure.args = c(
#    "--with-gdal-config=/usr/bin/gdal-config",
#    "--with-proj-data=/usr/share/proj"))

library(caret)
library(cols4all)
library(dplyr)
library(ModelMetrics)
#library(ForestTools)
library(e1071)
library(knitr)
library(latex2exp)
library(leaflet)
library(MASS)
library(Rcpp)
library(RcppThread)
library(randomForest)
library(rmarkdown)
library(sf)
library(sp)
library(terra)
library(tmap)
library(tmaptools)
library(tinytex)
library(raster)

base::options(htmltools.dir.version = F, htmltools.preserve.raw = F)

knitr::opts_chunk$set(
  echo    = TRUE, 
  message = FALSE, 
  warning = FALSE,
  error   = FALSE, 
  comment = NA,
  tidy.opts = list(width.cutoff = 120)
  ) 

sf::sf_use_s2(use_s2 = FALSE) # non-spherical geometries
#renv::restore() # reload packages if someone previously ran 'renv::init()' 
#renv::init() # save new package list after editing script 
```

```{css, echo=FALSE, class.source = 'foldable'}
#TOC::before {
  content: "";
  display: block;
  height: 80px;
  width: 210px;
  background-image: url(https://winrock.org/wp-content/uploads/2021/12/Winrock-logo-R.png);
  background-size: contain;
  background-position: 50% 50%;
  padding-top: 80px !important;
  background-repeat: no-repeat;
  }
```

## Summary

This analysis of the RSPB Gola REDD+ project provides a comparison of methodologies for deriving Activty Data, forest area estimates, and thefor jurisidictional allocation of forest risk. Please consider, this review is an early effort and remains open for correction or improvement, with the understanding that previous methods may yet provide the more accurate representation. In the following, preliminary results are highlighted from the feasibility study, and from our independent analysis herein. The focus is on forest cover estimates, deforestation rates, REDD+ scenarios, and emission reductions to highlight any methodological discrepancies and to provide recommendations.

**Forest Area Estimates** (2013/2014--2024):

-   Gola National Park:

    2013: Reported 88,881.98 ha; 2014 Reviewed 88,096.44 ha.

    2019: Reported 87,869.96 ha; Reviewed 87,869.96 ha.

    2024: Reported 88,177.83 ha; Reviewed 88,177.83 ha.

-   Norman:

    2013: Reported 6993.26 ha; 2014 Reviewed 6,988.65 ha.

    2019: Reviewed 6,963.31 ha.

    2024: Reviewed 6,993.08 ha.

-   Tonglay:

    2013: Reported 29,515.3 ha; 2014 Reviewed 29,362.95 ha.

    2019: Reviewed 29,152.85 ha.

    2024: Reviewed 29,345.93 ha.

-   Total Project Area:

    2014: Reported 125,328.36 ha; Reviewed 124,316.7 ha.

    2019: Reviewed 123,854.3 ha.

    2024: Reviewed 124,388 ha.

![](data/tables/Table%201%20Project%20files%20reviewed.png)

##### Table 1: Project files reviewed in this assessment

*Import AOI:*

```{r, eval=F}
set.seed(77777)
# Import project area aoi
aoi = sf::read_sf(".../OneDrive_Winrock/../Winrock_GIS Analysis Gola/ProjectArea.shp") 
aoi = aoi |>
  sf::st_cast("POLYGON") |>
  sf::st_cast("MULTIPOLYGON") |>
  dplyr::filter(
    NAME   == "Gola Forest National Park" | 
      NAME == "Tonglay" |
      NAME == "Normon")
# Import national area aoi
query = osmdata::opq("Liberia") |> # opq = overpass query
  osmdata::add_osm_feature(key = "boundary", value = "administrative") |>
  osmdata::osmdata_sf()
boundaries = query$osm_multipolygons
country  = boundaries |>
  dplyr::filter(admin_level == "2", name == "Liberia") |>
  dplyr::select(name, admin_level, geometry) |>
  sf::st_cast() |> 
  sf::st_transform(4326)
sf::st_write(country, "./data/aoi/liberia_boundary_national.shp", delete_layer=T)
```

```{r, echo=F, message=F, warning=F, error=F, comment=NA}
set.seed(77777)
aoi = sf::read_sf("./data/Winrock_GIS/ProjectArea.shp") 
aoi = aoi |>
  sf::st_cast("POLYGON") |>
  sf::st_cast("MULTIPOLYGON") |>
  dplyr::filter(
    NAME   == "Gola Forest National Park" | 
      NAME == "Tonglay" |
      NAME == "Normon") |>
  sf::st_transform(4326)
country = sf::read_sf("./data/aoi/liberia_boundary_national.shp")
bbox_country_1 = terra::vect(terra::ext(terra::vect(country)) * 1.1)
bbox_country_2 = terra::vect(terra::ext(terra::vect(country)) * 1.6)
bbox_aoi_1   = terra::vect(terra::ext(terra::vect(aoi)) * 1.1)
bbox_aoi_2   = terra::vect(terra::ext(terra::vect(aoi)) * 1.6)
bbox_aoi     = sf::st_as_sf(bbox_aoi_1) 
bbox_country = sf::st_as_sf(bbox_country_1) 
terra::crs(bbox_aoi_1)  = "epsg:4326"
terra::crs(bbox_aoi_2)  = "epsg:4326"
terra::crs(bbox_country_1)  = "epsg:4326"
terra::crs(bbox_country_2)  = "epsg:4326"
sf::st_crs(bbox_aoi)    = 4326
sf::st_crs(bbox_country)= 4326
```

```{r, eval=F}
tmap::tmap_mode("plot")
# zoom = 11 = 1:150,000 scale - https://wiki.openstreetmap.org/wiki/Zoom_levels
basemap_aoi = maptiles::get_tiles(
  bbox_aoi_2, 
  zoom      = 10, 
  crop      = T,
  provider  = "Esri.NatGeoWorldMap"
  )

basemap_country = maptiles::get_tiles(
  bbox_country_2, 
  zoom      = 8, 
  crop      = T,
  provider  = "Esri.NatGeoWorldMap"
  )

tmap::tm_shape(bbox_aoi) + tmap::tm_borders(lwd = 0.0) +
  tmap::tm_shape(basemap_aoi) + tmap::tm_rgb() + 
  tmap::tm_shape(aoi) + tmap::tm_borders(lwd = 2, col = "red") +
  tmap::tm_text("NAME", just = "center", col="black", size=0.6) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:32629", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position = c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark = "gray60", text.color = "gray60", position = c("left", "top")) -> tm1

tmap::tm_shape(bbox_country) + tmap::tm_borders(lwd = 0.0) +
  tmap::tm_shape(basemap_country) + tmap::tm_rgb() + 
  tmap::tm_shape(country) + tmap::tm_borders(col = "blue", lwd = 2) +
  tmap::tm_shape(aoi) + tmap::tm_borders(col = "red", lwd = 2) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position = c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark = "gray60", text.color = "gray60", position = c("left", "top")) -> tm2
                   
tmap::tmap_save(tm1, "./data/site_maps/site_map.png", height=10000, asp=0, dpi=2400)
tmap::tmap_save(tm2, "./data/site_maps/locator_map.png", height=10000, asp=0, dpi=2400)
tmap::tmap_arrange(tm1, tm2, ncol=2)
```

```{r, message=F, warning=F, error=F, comment=NA, cache=T, fig.show='hold', out.width="50%", eval=T}
knitr::include_graphics(c("./data/site_maps/site_map.png",
                          "./data/site_maps/locator_map.png"))
```

## Area check

In Liberia, the official definition of forest land is provided by the Forestry Development Authority [@governmentofliberiaLiberiasForestReference2019], including areas of land that meet the following criteria:

-   Canopy cover of minimum 30%;
-   Canopy height of minimum 5m or the capacity to reach it;
-   Covering a minimum of 1 hectare of land.

```{r, echo=F, message=F, warning=F, error=F, comment=NA}
aoi = sf::read_sf("./data/Winrock_GIS/ProjectArea.shp") 
```

```{r, message=F, warning=F, error=F, comment=NA}
aoi$area_m2 = round(as.numeric(sf::st_area(aoi) * 0.0001, 4))
aoi_select = aoi |>
  dplyr::select(NAME, DESIG, Areahav2, area_m2) |>
  dplyr::filter(
    NAME == "Gola Forest National Park" | 
      NAME == "Normon"  | 
      NAME == "Tonglay") |>
  sf::st_drop_geometry() |>
  janitor::adorn_totals() 
sf::st_transform(aoi, 4326)  
sf::st_transform(country, 4326) 
slivers = aoi |> dplyr::filter(as.numeric(area_m2) < 1)  # no artefacts found
aoi_select
```

##### Table 2: Project area estimates verified using sf & GDAL 3.10 drivers

Results indicate the spatial dataset is free from topological errors, and forest 'islands' and spatial artefacts smaller than approved area definition. Results also match Areahav2 values derived previously and reported in ER_Workbook_Gola_Liberia.xlsx

## Activity data check

This section documents inputs and procedures used to derive national and project-level deforestation maps. This follows three main steps:

-   Compare land cover training samples for Liberia;
-   Classify & assess accuracy of forest cover maps for 2014, 2019, and 2024;
-   Spatially map deforestation risk & compare with Liberia's submitted FREL estimates.

#### ***Training samples***

Training samples for the country and project area were extracted from two gold standard global land cover time series datasets: the GLanCE dataset [@stanimirovaGlobalLandCover2023] and TimeSpec4LULC dataset. Both training datasets were processed with continuous change and class migration algorithms. While Verra is yet to establish requirements for addressing feature class migration in classification of baseline activity data [@verraVM0048ReducingEmissions2023a; @verraVMD0055EstimationEmission2024; @verraVT0007UnplannedDeforestation2021], we may recommend incorporating this remote sensing best practice or showcase its improvements to accuracy metrics, as follows.

![](data/tables/Table%202%20Training%20samples%20class%20conversions.png)

##### Table 3: Class conversions of training samples

Level-1 classes in the GLanCE and TimeSpec4LULC datasets were recoded below to match class labels cited in the "Lookups" sheet of "ER_Workbook_Gola_Liberia.xlsx", and the report titled "Liberia's Forest Reference Emission Level Submission to the UNFCCC [@woodcockGlobalLandCover; @governmentofliberiaLiberiasForestReference2019].

```{r, eval=F}
# import & tidy samples
samples_raw = read.csv("./data/training_samples/glance_training.csv")
samples_clean = samples_raw |>
  dplyr::select(Lon, Lat, Glance_Class_ID_level1, Start_Year, End_Year)|>
  dplyr::rename(longitude = Lon) |>
  dplyr::rename(latitude = Lat) |>
  dplyr::rename(label_old = Glance_Class_ID_level1) |>
  dplyr::mutate(start_date = as.Date(paste(Start_Year,"01","01",sep = "-")))|>
  dplyr::mutate(end_date = as.Date(paste(End_Year, "01", "01", sep = "-")))|>
  dplyr::select(longitude, latitude, start_date, end_date, label_old)|>
  dplyr::mutate(code = case_when(
    label_old == '4' ~ 0, 
    label_old == '7' ~ 1, 
    label_old == '6' ~ 2, 
    label_old == '5' ~ 3, 
    label_old == '1' ~ 4, 
    label_old == '3' ~ 99, 
    label_old == '2' ~ 88)
    ) |>
  dplyr::mutate(label = case_when(
    code == '0'  ~ "Bareground", 
    code == '1'  ~ "Regrowth", 
    code == '2'  ~ "Farmbush", 
    code == '3'  ~ "Forest", 
    code == '4'  ~ "Water", 
    code == '99' ~ "Urban", 
    code == '88' ~ "Snow")
    ) |> 
  dplyr::mutate(label = as.factor(label)) |>
  dplyr::mutate(id = row_number()) |> 
  dplyr::select(-label_old) |>
  dplyr::select(-code)

# filter to project area
samples_sf       = sf::st_as_sf(samples_clean, crs = 4326, coords = c("longitude", "latitude"))
samples_clipped  = sf::st_intersection(samples_sf, country) # n = 364
samples_country  = samples_sf[samples_clipped, ] |> sf::st_transform(4326)
samples          = sf::st_crop(samples_country, st_bbox(country))
sf::st_write(samples, "./data/training_samples/glance_spatial_clip.shp", delete_dsn = T)
write.csv(samples, "./data/training_samples/glance_spatial_clip.csv", row.names = F)
dplyr::count(samples, label)
```

```{r, echo=F, message=F, warning=F, error=F, comment=NA}
samples = sf::st_read("./data/training_samples/glance_spatial_clip.shp")
samples <- samples |>
  mutate(id = row_number()) |>
  mutate(id = as.numeric(id)) |>
  mutate(label = as.factor(label))
dplyr::count(samples, label)

tmap::tmap_mode("view")
tmap::tm_shape(country) + tmap::tm_borders(col = "blue") +
  tmap::tm_shape(aoi) + tmap::tm_borders(col = "red", lwd = 2) + 
  tmap::tm_shape(samples) + tmap::tm_dots(col = "label", title = "LULC Samples") +
  tmap::tm_text("label",just="right",col="white",size=0.8) +
  tmap::tm_basemap("Esri.WorldImagery")
  
#leaflet(data = samples) %>%
 # addTiles() %>% # Add a background map
 # addCircleMarkers(label = ~as.character(label), labelOptions = list(permanent = T), radius = 10)
```

#### ***Raster collection***

The dataset of STAC-formatted Landsat Collection-2-Level-2 was extracted from the Google Earth Engine Catalog and processed using a cloudless and pixel quality ranking mask before back-filling with median normalization. This was implemented in a [Colab python runtime here](https://colab.research.google.com/github/seamusrobertmurphy/01-data-processing/blob/main/01-data-processing.ipynb). The collection of unclassified rasters was temporarily stored in a [Google Drive folder](https://drive.google.com/drive/folders/1XMYYhBUAsvuZ02avsZHYHDTArqztLaFI?usp=drive_link) and the consolidated, resampled and labelled full stack is available to download directly from [here](https://drive.google.com/file/d/1Vn0KDzkFDaBhpdC803IbYVRuu5cHx0SO/view?usp=drive_link). In addition, full script and all runtime setups are available from the project's github repository here

Landsat data was acquired instead of Sentinel imagery due to start date of project's 10-year baseline occurring before the launch of the Sentinel 2 satellite. The following chunk provides an alternative worflow, though less reliable, R-native workflow for acquiring, aligning, and processing rasters for the extent of Liberia.

```{r, eval=F}
roi <- st_bbox(country) %>% st_as_sfc()
# cube assembly
cube_2024_mpc <- sits_cube(
  source      = "MPC",
  collection  = "LANDSAT-C2-L2",
  roi         = roi,
  bands       = c("BLUE", "GREEN", "NIR08", "RED", "SWIR16", "SWIR22", "CLOUD"),
  start_date  = "2024-01-01",
  end_date    = "2024-02-01"
  )
# cloud-mask & normalization
cube_2024_reg <- sits_regularize(
  cube        = cube_2024_mpc,
  res         = 30,
  period      = "P60D",
  multicores  = 16,
  output_dir  = "./data/cube_stac")
# Derive NDVI
cube_2024_spectral = sits::sits_apply(
  data        = cube_2024_reg,
  NDVI        = (NIR08 - RED) / (NIR08 + RED), 
  output_dir  = "./data/cube_stac",
  memsize     = 8,
  multicores  = 16,
  progress    = T
  )
# Sequence of raster stack
STACK = brick(NDVI_2014, NDVI_2019, NDVI_2024,
          BLUE_2014, BLUE_2019, BLUE_2024, 
          GREEN_2014, GREEN_2019, GREEN_2024,
          NIR08_2014, NIR08_2019, NIR08_2024, 
          RED_2014, RED_2019, RED_2024, 
          SWIR16_2014, SWIR16_2019, SWIR16_2024, 
          SWIR22_2014, SWIR22_2019, SWIR22_2024,
          DEM)
```

The processes above were repeated for three baseline years of 2014, 2019, and 2024, which were then saved as raster stacked and visualized below.

```{r, eval=F, echo=F}
BLUE_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_BLUE_2014-01-04.tif") 
BLUE_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_BLUE_2019-01-02.tif")
BLUE_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_BLUE_2024-01-16.tif")
GREEN_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_GREEN_2014-01-04.tif")
GREEN_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_GREEN_2019-01-02.tif")
GREEN_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_GREEN_2024-01-16.tif")
NIR08_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_NIR08_2014-01-04.tif")
NIR08_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_NIR08_2019-01-02.tif")
NIR08_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_NIR08_2024-01-16.tif")
RED_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_RED_2014-01-04.tif")
RED_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_RED_2019-01-02.tif")
RED_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_RED_2024-01-16.tif")
SWIR16_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_SWIR16_2014-01-04.tif")
SWIR16_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_SWIR16_2019-01-02.tif")
SWIR16_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_SWIR16_2024-01-16.tif")
SWIR22_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_SWIR22_2014-01-04.tif")
SWIR22_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_SWIR22_2019-01-02.tif")
SWIR22_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_SWIR22_2024-01-16.tif")
NDVI_2014=terra::rast("./data/cube_2014/LANDSAT_TM-ETM-OLI_198055_NDVI_2014-01-04.tif")*0.0001 
NDVI_2019=terra::rast("./data/cube_2019/LANDSAT_TM-ETM-OLI_198055_NDVI_2019-01-02.tif")*0.0001 
NDVI_2024=terra::rast("./data/cube_2024/LANDSAT_TM-ETM-OLI_198055_NDVI_2024-01-16.tif")*0.0001 
DEM=terra::rast("./data/DEM/DEM_SRTMGL1_1ARCSEC_30M.tif")

NDVI_2014 = terra::project(NDVI_2014, "EPSG:4326")
NDVI_2019 = terra::project(NDVI_2019, "EPSG:4326")
NDVI_2024 = terra::project(NDVI_2024, "EPSG:4326")

BLUE_2014 = terra::resample(BLUE_2014, NDVI_2014) |> raster::raster() 
BLUE_2019 = terra::resample(BLUE_2019, NDVI_2014) |> raster::raster() 
BLUE_2024 = terra::resample(BLUE_2024, NDVI_2014) |> raster::raster() 
GREEN_2014 = terra::resample(GREEN_2014, NDVI_2014) |> raster::raster() 
GREEN_2019 = terra::resample(GREEN_2019, NDVI_2014) |> raster::raster() 
GREEN_2024 = terra::resample(GREEN_2024, NDVI_2014) |> raster::raster() 
NIR08_2014 = terra::resample(NIR08_2014, NDVI_2014) |> raster::raster() 
NIR08_2019 = terra::resample(NIR08_2019, NDVI_2014) |> raster::raster() 
NIR08_2024 = terra::resample(NIR08_2024, NDVI_2014) |> raster::raster() 
RED_2014 = terra::resample(RED_2014, NDVI_2014) |> raster::raster() 
RED_2019 = terra::resample(RED_2019, NDVI_2014) |> raster::raster() 
RED_2024 = terra::resample(RED_2024, NDVI_2014) |> raster::raster() 
SWIR16_2014 = terra::resample(SWIR16_2014, NDVI_2014) |> raster::raster() 
SWIR16_2019 = terra::resample(SWIR16_2019, NDVI_2014) |> raster::raster() 
SWIR16_2024 = terra::resample(SWIR16_2024, NDVI_2014) |> raster::raster() 
SWIR22_2014 = terra::resample(SWIR22_2014, NDVI_2014) |> raster::raster() 
SWIR22_2019 = terra::resample(SWIR22_2019, NDVI_2014) |> raster::raster() 
SWIR22_2024 = terra::resample(SWIR22_2024, NDVI_2014) |> raster::raster()
NDVI_2014 = raster::raster(NDVI_2014) 
NDVI_2019 = raster::raster(NDVI_2019) 
NDVI_2024 = raster::raster(NDVI_2024) 

raster::writeRaster(BLUE_2014, "./data/STACK/BLUE_2014.tif", format = "GTiff", overwrite = T)
raster::writeRaster(BLUE_2019, "./data/STACK/BLUE_2019.tif", format = "GTiff", overwrite = T)
raster::writeRaster(BLUE_2024, "./data/STACK/BLUE_2024.tif", format = "GTiff", overwrite = T)
raster::writeRaster(GREEN_2014, "./data/STACK/GREEN_2014.tif", format = "GTiff", overwrite = T)
raster::writeRaster(GREEN_2019, "./data/STACK/GREEN_2019.tif", format = "GTiff", overwrite = T)
raster::writeRaster(GREEN_2024, "./data/STACK/GREEN_2024.tif", format = "GTiff", overwrite = T)
raster::writeRaster(NIR08_2014, "./data/STACK/NIR08_2014.tif", format = "GTiff", overwrite = T)
raster::writeRaster(NIR08_2019, "./data/STACK/NIR08_2019.tif", format = "GTiff", overwrite = T)
raster::writeRaster(NIR08_2024, "./data/STACK/NIR08_2024.tif", format = "GTiff", overwrite = T)
raster::writeRaster(RED_2014, "./data/STACK/RED_2014.tif", format = "GTiff", overwrite = T)
raster::writeRaster(RED_2019, "./data/STACK/RED_2019.tif", format = "GTiff", overwrite = T)
raster::writeRaster(RED_2024, "./data/STACK/RED_2024.tif", format = "GTiff", overwrite = T)
raster::writeRaster(SWIR16_2014, "./data/STACK/SWIR16_2014.tif", format = "GTiff",overwrite=T)
raster::writeRaster(SWIR16_2019, "./data/STACK/SWIR16_2019.tif", format = "GTiff",overwrite=T)
raster::writeRaster(SWIR16_2024, "./data/STACK/SWIR16_2024.tif", format = "GTiff",overwrite=T)
raster::writeRaster(SWIR22_2014, "./data/STACK/SWIR22_2014.tif", format = "GTiff",overwrite=T)
raster::writeRaster(SWIR22_2019, "./data/STACK/SWIR22_2019.tif", format = "GTiff",overwrite=T)
raster::writeRaster(SWIR22_2024, "./data/STACK/SWIR22_2024.tif", format = "GTiff",overwrite=T)
raster::writeRaster(NDVI_2014, "./data/STACK/NDVI_2014.tif", format = "GTiff", overwrite = T)
raster::writeRaster(NDVI_2019, "./data/STACK/NDVI_2019.tif", format = "GTiff", overwrite = T)
raster::writeRaster(NDVI_2024, "./data/STACK/NDVI_2024.tif", format = "GTiff", overwrite = T)

NDVI_2014=terra::rast("./data/STACK/NDVI_2014.tif")
DEM=terra::rast("./data/DEM/DEM_SRTMGL1_1ARCSEC_30M.tif") |> terra::project(crs(NDVI_2014))
DEM=terra::resample(DEM, NDVI_2014)
DEM=terra::crop(DEM, NDVI_2014)
DEM=terra::mask(DEM, NDVI_2014)
DEM_raster=raster::raster(DEM)
raster::writeRaster(DEM_raster, "./data/STACK/DEM.tif", format = "GTiff", overwrite = T)

BLUE_2014=raster::raster("./data/STACK/BLUE_2014.tif")
BLUE_2019=raster::raster("./data/STACK/BLUE_2019.tif")
BLUE_2024=raster::raster("./data/STACK/BLUE_2024.tif")
GREEN_2014=raster::raster("./data/STACK/GREEN_2014.tif")
GREEN_2019=raster::raster("./data/STACK/GREEN_2019.tif")
GREEN_2024=raster::raster("./data/STACK/GREEN_2024.tif")
NIR08_2014=raster::raster("./data/STACK/NIR08_2014.tif")
NIR08_2019=raster::raster("./data/STACK/NIR08_2019.tif")
NIR08_2024=raster::raster("./data/STACK/NIR08_2024.tif")
RED_2014=raster::raster("./data/STACK/RED_2014.tif")
RED_2019=raster::raster("./data/STACK/RED_2019.tif")
RED_2024=raster::raster("./data/STACK/RED_2024.tif")
SWIR16_2014=raster::raster("./data/STACK/SWIR16_2014.tif")
SWIR16_2019=raster::raster("./data/STACK/SWIR16_2019.tif")
SWIR16_2024=raster::raster("./data/STACK/SWIR16_2024.tif")
SWIR22_2014=raster::raster("./data/STACK/SWIR22_2014.tif")
SWIR22_2019=raster::raster("./data/STACK/SWIR22_2019.tif")
SWIR22_2024=raster::raster("./data/STACK/SWIR22_2024.tif")
NDVI_2014=raster::raster("./data/STACK/NDVI_2014.tif")
NDVI_2019=raster::raster("./data/STACK/NDVI_2019.tif")
NDVI_2024=raster::raster("./data/STACK/NDVI_2024.tif")
DEM=raster::raster("./data/STACK/DEM.tif")

STACK = brick(NDVI_2014, NDVI_2019, NDVI_2024,
          BLUE_2014, BLUE_2019, BLUE_2024, 
          GREEN_2014, GREEN_2019, GREEN_2024,
          NIR08_2014, NIR08_2019, NIR08_2024, 
          RED_2014, RED_2019, RED_2024, 
          SWIR16_2014, SWIR16_2019, SWIR16_2024, 
          SWIR22_2014, SWIR22_2019, SWIR22_2024,
          DEM)

raster::writeRaster(STACK,"./data/STACK/LANDSAT_TM-ETM-OLI_198055_STACK-&-DEM_2014-01-04_2024-01-16.tif",format = "GTiff", bandorder = "BIL", overwrite = T)
```

```{r, message=F, warning=F, error=F, comment=NA, fig.show='hold', out.width="33%"}
# import
NDVI_2014=terra::rast("./data/STACK/LANDSAT_TM-ETM-OLI_198055_NDVI_2014-01-04.tif")
NDVI_2019=terra::rast("./data/STACK/LANDSAT_TM-ETM-OLI_198055_NDVI_2019-01-02.tif")
NDVI_2024=terra::rast("./data/STACK/LANDSAT_TM-ETM-OLI_198055_NDVI_2024-01-16.tif")
STACK=raster::brick("./data/STACK/LANDSAT_TM-ETM-OLI_198055_STACK-&-DEM_2014-01-04_2024-01-16.tif")

# visualize
hist(NDVI_2014, main = "NDVI Distribution, 2014", col = "springgreen") 
hist(NDVI_2019, main = "NDVI Distribution, 2019", col = "springgreen")
hist(NDVI_2024, main = "NDVI Distribution, 2024", col = "springgreen")
plot(NDVI_2014,main="NDVI, 2014",xlim=c(-11.5,-7.5),ylim=c(4.1,8.6),border="gray")
plot(st_geometry(samples), add=T)
plot(NDVI_2019,main="NDVI, 2014",xlim=c(-11.5,-7.5),ylim=c(4.1,8.6),border="gray")
plot(st_geometry(samples), add=T)
plot(NDVI_2024,main="NDVI, 2014",xlim=c(-11.5,-7.5),ylim=c(4.1,8.6),border="gray")
plot(st_geometry(samples), add=T)
```

```{r, echo=F}
names(STACK[[1]]) = "NDVI_2014"
names(STACK[[2]]) = "NDVI_2019"
names(STACK[[3]]) = "NDVI_2024"
names(STACK[[4]]) = "BLUE_2014"
names(STACK[[5]]) = "BLUE_2019"
names(STACK[[6]]) = "BLUE_2024"
names(STACK[[7]]) = "GREEN_2014"
names(STACK[[8]]) = "GREEN_2019"
names(STACK[[9]]) = "GREEN_2024"
names(STACK[[10]]) = "NIR08_2014"
names(STACK[[11]]) = "NIR08_2019"
names(STACK[[12]]) = "NIR08_2024"
names(STACK[[13]]) = "RED_2014"
names(STACK[[14]]) = "RED_2019"
names(STACK[[15]]) = "RED_2024"
names(STACK[[16]]) = "SWIR16_2014"
names(STACK[[17]]) = "SWIR16_2019"
names(STACK[[18]]) = "SWIR16_2024"
names(STACK[[19]]) = "SWIR22_2014"
names(STACK[[20]]) = "SWIR22_2019"
names(STACK[[21]]) = "SWIR22_2024"
names(STACK[[22]]) = "DEM"
STACK_2019=subset(STACK, c("NDVI_2019","BLUE_2019","GREEN_2019","NIR08_2019",
                           "RED_2019","SWIR16_2019","SWIR22_2019","DEM"))
STACK_2024=subset(STACK, c("NDVI_2024","BLUE_2024","GREEN_2024","NIR08_2024",
                           "RED_2024","SWIR16_2024","SWIR22_2024","DEM"))
```

#### ***Image classification***

We trained a Random Forest model fitted with 500 decision trees. Training/test split partitioned the dataset using a 70:30 ratio. Accuracy assessments were reported using a confusion matrix for full model and cross-validation estimates. Uncertainty metrics were used to select best subset of variables according to magnitude and performance. Models were then calibrated in number regression trees and architecture rules, with cross-validation reported to assess internal bias from true population estimates before and to improve uncertainty of final model deployment.

```{r, message=F, warning=F, error=F, comment=NA, cache=T}
# extract yearly layers
STACK_2014=subset(STACK, c("NDVI_2014","BLUE_2014","GREEN_2014","NIR08_2014",
                           "RED_2014","SWIR16_2014","SWIR22_2014","DEM"))
# extract signatures
signatures_2014 = raster::extract(STACK_2014, samples ,df=T) # watch for data formats
samples_signatures_2014 <- dplyr::inner_join(signatures_2014, samples, by=c("ID"="id"))
samples_signatures_2014$geometry <- NULL # set geometry to NULL for model training

# training-test split, p=0.7 -> 70% split
trainIndex_2014 <- caret::createDataPartition(samples_signatures_2014$ID,list=F,p=0.7)
trainData_2014  <- samples_signatures_2014[trainIndex_2014,]  
testData_2014   <- samples_signatures_2014[-trainIndex_2014,] 

# interpolate NAs with class-median-normalization (NAs -> missing cloud pixels)
trainData_2014 <- trainData_2014 |> group_by(label) |> mutate(across(where(is.numeric),
    ~ ifelse(is.na(.), median(., na.rm = TRUE), .))) |> ungroup()
testData_2014 <- testData_2014 |> group_by(label) |> mutate(across(where(is.numeric),
    ~ ifelse(is.na(.), median(., na.rm = TRUE), .))) |> ungroup()

# assign model variables
response  <- c("label")
predictors_2014 <- c(
  "NDVI_2014", "BLUE_2014", "GREEN_2014", "RED_2014", 
  "NIR08_2014", "SWIR16_2014", "SWIR22_2014", "DEM"
  )
# set training parameters
cv_regime <- caret::trainControl(
  method          = 'cv',
  number          = 10,
  savePredictions = T,
  verboseIter     = F
  )

# train classifier
rf_model_2014 <- caret::train(
  label~.,
  data = trainData_2014[, c(predictors_2014, "label")], # drop ID var
  trControl = cv_regime,
  method    = "rf", 
  metric    = 'Kappa', 
  ntree     = 500,
  tuneLength= 6,
  importance= T
  )
```

***Accuracy assessments***[^1]

[^1]: Please note that model performance metrics differ slightly with each new runtime due to Monte Carlo resampling and the number of randomForest decision trees. This is to say that accuracy results that refresh each run in the chunk below may not be precisely matching the in-line reporting summaries above them here.

Results indicated that the model performed well during cross-validation, achieving a Kappa value of 0.753 and an Accuracy of 94.44% at an optimal mtry of 11.

In the blind data test, the model exhibited similar performance, achieving a Kappa Index of 0.753 and an Accuracy of 94.44%. This was accompanied by a No Information Rate (NIR) of 86.11%, indicating the model's significant predictive power (ACC = 0.9444, 95% CI [0.883, 0.9793], NIR = 0.8611).

While further investigation is warranted, these results suggest a moderate concordance between observed and predicted classes. Notably, key classes such as `Forest` and `Urban` were predicted with robust Sensitivity and Specificity (e.g., Forest: SE = 0.9892, SP = 0.7333).

However, the absence of predictions for the `Farmbush` and `Water` classes points to potential issues with class imbalance or insufficient representation in the training data. To address these model weaknesses, we may recommend experimenting with weighted Random Forest or alternative algorithms such as Gradient Boosting or Support Vector Machines (SVM) may improve performance for underrepresented classes. The decision to explore additional modeling strategies is left to the discretion of project leaders.

```{r, message=F, warning=F, error=F, comment=NA, cache=T}
rf_test_2014 <- predict(rf_model_2014, testData_2014)
print(rf_model_2014) # cv results
caret::confusionMatrix(rf_test_2014,testData_2014$label) # blind test results
```

#### *Model calibration*

We employed recursive predictor subsetting to identify predictors of greatest magnitude and non-informative features to enhance model performance and reduce model complexity, respectively. This aims to limit potential of multicolinearity, despite inherent robustness of randomForest algorithms against such violations. The subsetted model was evaluated on the test dataset. The confusion matrix and performance metrics were summarized below.

```{r, message=F, warning=F, error=F, comment=NA, cache=T}
index_feature_2014 <- createMultiFolds(trainData_2014$label, times=5) 
predictor_seq_2014 <-seq(from=1, to=length(predictors_2014),by=2)

subset_regime_2014 <- rfeControl(
  method="cv",
  number = 10,
  verbose=FALSE,
  functions=rfFuncs,
  index=index_feature_2014
  )

rf_model_subset_2014 <- caret::rfe(
  label~.,
  data = trainData_2014[, c(predictors_2014, "label")], 
  sizes = predictor_seq_2014,
  metric = "Kappa",
  ntree=500,
  method="rf",
  rfeControl = subset_regime_2014
  )

rf_subset_test_2014 <- predict(rf_model_subset_2014,testData_2014)
print(rf_model_subset_2014)
caret::confusionMatrix(rf_subset_test_2014$pred,testData_2014$label)
```

In summary, the subset model achieved an Accuracy of 96.30% and a Kappa Index of 0.8456. These metrics closely align with the results of the original model, suggesting minimal or no loss in predictive power despite using fewer predictors. Similarly, high-performing classes of `Forest` and `Urban` maintained sensitivity and specificity. For example, `TreeCover` had a Sensitivity of 0.9892 and Specificity of 0.8667, while `Urban` had a Sensitivity of 0.90909 and Specificity of 0.98969. Given that the reduction in complexity offered by the subsetted model does not provide significant benefits in this context, we recommend proceeding with the original model to make spatial predictions.

These modelling operations were repeated for 2019 and 2024 (see Appendix).

Spatial predictions were made using their respective models and outputs of classified LULC rasters were saved in the same Google Drive folder linked above in previous sections.

```{r, eval=F, message=F, warning=F, error=F, fig.show='hold', out.width="33%"}
# predict lulc rasters
LULC_LIBERIA_2014 <- raster::predict(STACK_2014,rf_model_2014) 
LULC_LIBERIA_2019 <- raster::predict(STACK_2019,rf_model_2019) 
LULC_LIBERIA_2024 <- raster::predict(STACK_2024,rf_model_2024) 

# save lulc rasters
raster::writeRaster(LULC_LIBERIA_2014,"./data/LULC/LULC_LIBERIA_2014-01-04.tif",
  format = "GTiff",overwrite = T)
raster::writeRaster(LULC_LIBERIA_2019,"./data/LULC/LULC_LIBERIA_2019-01-02.tif",
  format = "GTiff",overwrite = T)
raster::writeRaster(LULC_LIBERIA_2024,"./data/LULC/LULC_LIBERIA_2024-01-16.tif",
  format = "GTiff",overwrite = T)

# visualise lulc rasters
LULC_LIBERIA_2014 = raster::raster("./data/LULC/LULC_LIBERIA_2014-01-04.tif")
LULC_LIBERIA_2019 = raster::raster("./data/LULC/LULC_LIBERIA_2019-01-02.tif")
LULC_LIBERIA_2024 = raster::raster("./data/LULC/LULC_LIBERIA_2024-01-16.tif")
terra::plot(LULC_LIBERIA_2014, main="Land Cover Classification, 2014")
terra::plot(LULC_LIBERIA_2019, main="Land Cover Classification, 2019")
terra::plot(LULC_LIBERIA_2024, main="Land Cover Classification, 2024")
```

```{r, message=F, error=F, cache=T, echo=F, fig.show='hold', out.width="33%"}
LULC_LIBERIA_2014=terra::rast("./data/LULC/LULC_LIBERIA_2014-01-04.tif")
LULC_LIBERIA_2019=terra::rast("./data/LULC/LULC_LIBERIA_2019-01-02.tif")
LULC_LIBERIA_2024=terra::rast("./data/LULC/LULC_LIBERIA_2024-01-16.tif")
code_dict <- data.frame(
  id = c(1, 2, 3, 4, 5),
  label = c("Bareground", "Regrowth", "Forest", "Urban", "Water")
  )

levels(LULC_LIBERIA_2014) <- code_dict
levels(LULC_LIBERIA_2019) <- code_dict
levels(LULC_LIBERIA_2024) <- code_dict
terra::plot(LULC_LIBERIA_2014, main="Land Cover Classification, 2014")
terra::plot(LULC_LIBERIA_2019, main="Land Cover Classification, 2019")
terra::plot(LULC_LIBERIA_2024, main="Land Cover Classification, 2024")
```

### Forest area mapping

```{r, fig.show='hold', out.width="33%", eval=F}
# Forest binary maps
forest_class = 3
forest_2014 <- LULC_LIBERIA_2014 == forest_class
forest_2019 <- LULC_LIBERIA_2019 == forest_class
forest_2024 <- LULC_LIBERIA_2024 == forest_class
# Forest loss maps
forest_loss_2014_2019 <- forest_2014 & !forest_2019
forest_loss_2019_2024 <- forest_2019 & !forest_2024
forest_loss_2014_2024 <- forest_2014 & !forest_2024

# Write to disk
raster::writeRaster(forest_2014, "./data/LULC/forest_2014.tif",overwrite=T)
raster::writeRaster(forest_2019, "./data/LULC/forest_2019.tif",overwrite=T)
raster::writeRaster(forest_2024, "./data/LULC/forest_2024.tif",overwrite=T)
raster::writeRaster(forest_loss_2014_2019, "./data/LULC/forest_loss_2014_2019.tif",overwrite=T)
raster::writeRaster(forest_loss_2019_2024, "./data/LULC/forest_loss_2019_2024.tif",overwrite=T)
raster::writeRaster(forest_loss_2014_2024, "./data/LULC/forest_loss_2014_2024.tif",overwrite=T)
```

```{r, fig.show='hold', out.width="33%", echo=F}
forest_2014=terra::rast("./data/LULC/forest_2014.tif")
forest_2019=terra::rast("./data/LULC/forest_2019.tif")
forest_2024=terra::rast("./data/LULC/forest_2024.tif")
forest_loss_2014_2019=terra::rast("./data/LULC/forest_loss_2014_2019.tif")
forest_loss_2019_2024=terra::rast("./data/LULC/forest_loss_2019_2024.tif")
forest_loss_2014_2024=terra::rast("./data/LULC/forest_loss_2014_2024.tif")
code_dict_2 <- data.frame(id = c(0, 1), label = c("Non-forest", "Forest"))
code_dict_3 <- data.frame(id = c(0, 1), label = c("Stable", "Loss"))
levels(forest_2014) <- code_dict_2
levels(forest_2019) <- code_dict_2
levels(forest_2024) <- code_dict_2
levels(forest_loss_2014_2019) <- code_dict_3
levels(forest_loss_2019_2024) <- code_dict_3
levels(forest_loss_2014_2024) <- code_dict_3
terra::plot(forest_2014, main="Binary Forest Cover Map, 2014")
terra::plot(forest_2019, main="Binary Forest Cover Map, 2019")
terra::plot(forest_2024, main="Binary Forest Cover Map, 2024")
terra::plot(forest_loss_2014_2019, main="Forest Loss 2014-2019")
terra::plot(forest_loss_2019_2024, main="Forest Loss 2019-2024")
terra::plot(forest_loss_2014_2024, main="Forest Loss 2014-2024")
```

### Forest area estimates

```{r, eval=F, echo=F}
aoi = aoi |> sf::st_transform(crs(forest_2014))
aoi_project = aoi |>
  dplyr::select(NAME) |>
  dplyr::filter(NAME == "Gola Forest National Park" | 
                  NAME == "Normon"  | NAME == "Tonglay") 

aoi_gola = aoi_project |> dplyr::filter(NAME == "Gola Forest National Park")
aoi_tong = aoi_project |> dplyr::filter(NAME == "Tonglay")
aoi_norm = aoi_project |> dplyr::filter(NAME == "Normon")

vect_gola = terra::vect(aoi_gola)
vect_tong = terra::vect(aoi_tong)
vect_norm = terra::vect(aoi_norm)
vect_project = terra::vect(aoi_project)

mask_gola = stars::st_rasterize(aoi_gola)
mask_tong = stars::st_rasterize(aoi_tong)
mask_norm = stars::st_rasterize(aoi_norm)
mask_project = stars::st_rasterize(aoi_project)

mask_gola_rast <- terra::rast(mask_gola)
mask_tong_rast <- terra::rast(mask_tong)
mask_norm_rast <- terra::rast(mask_norm)
mask_project_rast <- terra::rast(mask_project)

raster::writeRaster(mask_gola_rast, "./data/LULC/mask_gola.tif", overwrite=T)
raster::writeRaster(mask_tong_rast, "./data/LULC/mask_tong.tif", overwrite=T)
raster::writeRaster(mask_norm_rast, "./data/LULC/mask_norm.tif", overwrite=T)
raster::writeRaster(mask_project_rast, "./data/LULC/mask_project.tif", overwrite=T)

mask_gola = terra::rast("./data/LULC/mask_gola.tif")
mask_tong = terra::rast("./data/LULC/mask_tong.tif")
mask_norm = terra::rast("./data/LULC/mask_norm.tif")
mask_project = terra::rast("./data/LULC/mask_project.tif")
mask_gola=terra::resample(mask_gola, forest_2014)
mask_tong=terra::resample(mask_tong, forest_2014)
mask_norm=terra::resample(mask_norm, forest_2014)
mask_project=terra::resample(mask_project, forest_2014)

forest_2014_gola = terra::crop(forest_2014, mask_gola)
forest_2014_tong = terra::crop(forest_2014, mask_tong)
forest_2014_norm = terra::crop(forest_2014, mask_norm)
forest_2014_project = terra::crop(forest_2014, mask_project)

forest_2014_gola = terra::mask(forest_2014_gola, mask_gola)
forest_2014_tong = terra::mask(forest_2014_tong, mask_tong)
forest_2014_norm = terra::mask(forest_2014_norm, mask_norm)
forest_2014_project = terra::mask(forest_2014_project, mask_project)

forest_2014_gola = terra::crop(forest_2014_gola, vect_gola)
forest_2014_tong = terra::crop(forest_2014_tong, vect_tong)
forest_2014_norm = terra::crop(forest_2014_norm, vect_norm)
forest_2014_project = terra::crop(forest_2014_project, vect_project)

forest_2014_gola = raster::raster(forest_2014_gola)
forest_2014_tong = raster::raster(forest_2014_tong)
forest_2014_norm = raster::raster(forest_2014_norm)
forest_2014_project = raster::raster(forest_2014_project)

raster::writeRaster(forest_2014_gola, "./data/LULC/forest_2014_gola.tif", overwrite = T)
raster::writeRaster(forest_2014_tong, "./data/LULC/forest_2014_tong.tif", overwrite = T)
raster::writeRaster(forest_2014_norm, "./data/LULC/forest_2014_norm.tif", overwrite = T)
raster::writeRaster(forest_2014_project, "./data/LULC/forest_2014_project.tif", overwrite = T)

forest_2019_gola = terra::crop(forest_2019, mask_gola)
forest_2019_tong = terra::crop(forest_2019, mask_tong)
forest_2019_norm = terra::crop(forest_2019, mask_norm)
forest_2019_project = terra::crop(forest_2019, mask_project)

forest_2019_gola = terra::mask(forest_2019_gola, mask_gola)
forest_2019_tong = terra::mask(forest_2019_tong, mask_tong)
forest_2019_norm = terra::mask(forest_2019_norm, mask_norm)
forest_2019_project = terra::mask(forest_2019_project, mask_project)

forest_2019_gola = terra::crop(forest_2019_gola, vect_gola)
forest_2019_tong = terra::crop(forest_2019_tong, vect_tong)
forest_2019_norm = terra::crop(forest_2019_norm, vect_norm)
forest_2019_project = terra::crop(forest_2019_project, vect_project)

forest_2019_gola = raster::raster(forest_2019_gola)
forest_2019_tong = raster::raster(forest_2019_tong)
forest_2019_norm = raster::raster(forest_2019_norm)
forest_2019_project = raster::raster(forest_2019_project)

raster::writeRaster(forest_2019_gola,"./data/LULC/forest_2019_gola.tif",overwrite=T)
raster::writeRaster(forest_2019_tong,"./data/LULC/forest_2019_tong.tif", overwrite = T)
raster::writeRaster(forest_2019_norm, "./data/LULC/forest_2019_norm.tif", overwrite = T)
raster::writeRaster(forest_2019_project, "./data/LULC/forest_2019_project.tif", overwrite = T)

forest_2024_gola = terra::crop(forest_2024, mask_gola)
forest_2024_tong = terra::crop(forest_2024, mask_tong)
forest_2024_norm = terra::crop(forest_2024, mask_norm)
forest_2024_project = terra::crop(forest_2024, mask_project)

forest_2024_gola = terra::mask(forest_2024_gola, mask_gola)
forest_2024_tong = terra::mask(forest_2024_tong, mask_tong)
forest_2024_norm = terra::mask(forest_2024_norm, mask_norm)
forest_2024_project = terra::mask(forest_2024_project, mask_project)

forest_2024_gola = terra::crop(forest_2024_gola, vect_gola)
forest_2024_tong = terra::crop(forest_2024_tong, vect_tong)
forest_2024_norm = terra::crop(forest_2024_norm, vect_norm)
forest_2024_project = terra::crop(forest_2024_project, vect_project)

forest_2024_gola = raster::raster(forest_2024_gola)
forest_2024_tong = raster::raster(forest_2024_tong)
forest_2024_norm = raster::raster(forest_2024_norm)
forest_2024_project = raster::raster(forest_2024_project)

raster::writeRaster(forest_2024_gola, "./data/LULC/forest_2024_gola.tif", overwrite = T)
raster::writeRaster(forest_2024_tong, "./data/LULC/forest_2024_tong.tif", overwrite = T)
raster::writeRaster(forest_2024_norm, "./data/LULC/forest_2024_norm.tif", overwrite = T)
raster::writeRaster(forest_2024_project, "./data/LULC/forest_2024_project.tif", overwrite = T)


forest_loss_2014_2019_gola = terra::crop(forest_loss_2014_2019, mask_gola)
forest_loss_2014_2019_tong = terra::crop(forest_loss_2014_2019, mask_tong)
forest_loss_2014_2019_norm = terra::crop(forest_loss_2014_2019, mask_norm)
forest_loss_2014_2019_project = terra::crop(forest_loss_2014_2019, mask_project)

forest_loss_2014_2019_gola = terra::mask(forest_loss_2014_2019_gola, mask_gola)
forest_loss_2014_2019_tong = terra::mask(forest_loss_2014_2019_tong, mask_tong)
forest_loss_2014_2019_norm = terra::mask(forest_loss_2014_2019_norm, mask_norm)
forest_loss_2014_2019_project = terra::mask(forest_loss_2014_2019_project, mask_project)

forest_loss_2014_2019_gola = terra::crop(forest_loss_2014_2019_gola, vect_gola)
forest_loss_2014_2019_tong = terra::crop(forest_loss_2014_2019_tong, vect_tong)
forest_loss_2014_2019_norm = terra::crop(forest_loss_2014_2019_norm, vect_norm)
forest_loss_2014_2019_project = terra::crop(forest_loss_2014_2019_project, vect_project)

forest_loss_2014_2019_gola = raster::raster(forest_loss_2014_2019_gola)
forest_loss_2014_2019_tong = raster::raster(forest_loss_2014_2019_tong)
forest_loss_2014_2019_norm = raster::raster(forest_loss_2014_2019_norm)
forest_loss_2014_2019_project = raster::raster(forest_loss_2014_2019_project)

raster::writeRaster(forest_loss_2014_2019_gola, "./data/LULC/forest_loss_2014_2019_gola.tif", overwrite = T)
raster::writeRaster(forest_loss_2014_2019_tong, "./data/LULC/forest_loss_2014_2019_tong.tif", overwrite = T)
raster::writeRaster(forest_loss_2014_2019_norm, "./data/LULC/forest_loss_2014_2019_norm.tif", overwrite = T)
raster::writeRaster(forest_loss_2014_2019_project, "./data/LULC/forest_loss_2014_2019_project.tif", overwrite = T)

forest_loss_2019_2024_gola = terra::crop(forest_loss_2019_2024, mask_gola)
forest_loss_2019_2024_tong = terra::crop(forest_loss_2019_2024, mask_tong)
forest_loss_2019_2024_norm = terra::crop(forest_loss_2019_2024, mask_norm)
forest_loss_2019_2024_project = terra::crop(forest_loss_2019_2024, mask_project)

forest_loss_2019_2024_gola = terra::mask(forest_loss_2019_2024_gola, mask_gola)
forest_loss_2019_2024_tong = terra::mask(forest_loss_2019_2024_tong, mask_tong)
forest_loss_2019_2024_norm = terra::mask(forest_loss_2019_2024_norm, mask_norm)
forest_loss_2019_2024_project = terra::mask(forest_loss_2019_2024_project, mask_project)

forest_loss_2014_2019_gola = terra::crop(forest_loss_2019_2024_gola, vect_gola)
forest_loss_2014_2019_tong = terra::crop(forest_loss_2019_2024_tong, vect_tong)
forest_loss_2014_2019_norm = terra::crop(forest_loss_2019_2024_norm, vect_norm)
forest_loss_2014_2019_project = terra::crop(forest_loss_2019_2024_project, vect_project)

forest_loss_2019_2024_gola = raster::raster(forest_loss_2019_2024_gola)
forest_loss_2019_2024_tong = raster::raster(forest_loss_2019_2024_tong)
forest_loss_2019_2024_norm = raster::raster(forest_loss_2019_2024_norm)
forest_loss_2019_2024_project = raster::raster(forest_loss_2019_2024_project)

raster::writeRaster(forest_loss_2019_2024_gola, "./data/LULC/forest_loss_2019_2024_gola.tif", overwrite = T)
raster::writeRaster(forest_loss_2019_2024_tong, "./data/LULC/forest_loss_2019_2024_tong.tif", overwrite = T)
raster::writeRaster(forest_loss_2019_2024_norm, "./data/LULC/forest_loss_2019_2024_norm.tif", overwrite = T)
raster::writeRaster(forest_loss_2019_2024_project, "./data/LULC/forest_loss_2019_2024_project.tif", overwrite = T)

forest_loss_2014_2024_gola = terra::crop(forest_loss_2014_2024, mask_gola)
forest_loss_2014_2024_tong = terra::crop(forest_loss_2014_2024, mask_tong)
forest_loss_2014_2024_norm = terra::crop(forest_loss_2014_2024, mask_norm)
forest_loss_2014_2024_project = terra::crop(forest_loss_2014_2024, mask_project)

forest_loss_2014_2024_gola = terra::mask(forest_loss_2014_2024_gola, mask_gola)
forest_loss_2014_2024_tong = terra::mask(forest_loss_2014_2024_tong, mask_tong)
forest_loss_2014_2024_norm = terra::mask(forest_loss_2014_2024_norm, mask_norm)
forest_loss_2014_2024_project = terra::mask(forest_loss_2014_2024_project, mask_project)

forest_loss_2014_2024_gola = terra::crop(forest_loss_2014_2024_gola, vect_gola)
forest_loss_2014_2024_tong = terra::crop(forest_loss_2014_2024_tong, vect_tong)
forest_loss_2014_2024_norm = terra::crop(forest_loss_2014_2024_norm, vect_norm)
forest_loss_2014_2024_project = terra::crop(forest_loss_2014_2024_project, vect_project)

forest_loss_2014_2024_gola = raster::raster(forest_loss_2014_2024_gola)
forest_loss_2014_2024_tong = raster::raster(forest_loss_2014_2024_tong)
forest_loss_2014_2024_norm = raster::raster(forest_loss_2014_2024_norm)
forest_loss_2014_2024_project = raster::raster(forest_loss_2014_2024_project)

raster::writeRaster(forest_loss_2014_2024_gola, "./data/LULC/forest_loss_2014_2024_gola.tif", overwrite = T)
raster::writeRaster(forest_loss_2014_2024_tong, "./data/LULC/forest_loss_2014_2024_tong.tif", overwrite = T)
raster::writeRaster(forest_loss_2014_2024_norm, "./data/LULC/forest_loss_2014_2024_norm.tif", overwrite = T)
raster::writeRaster(forest_loss_2014_2024_project, "./data/LULC/forest_loss_2014_2024_project.tif", overwrite = T)
```

```{r, echo=F, cache=T, eval=T}
forest_2014_gola = terra::rast("./data/LULC/forest_2014_gola.tif")
forest_2014_tong = terra::rast("./data/LULC/forest_2014_tong.tif")
forest_2014_norm = terra::rast("./data/LULC/forest_2014_norm.tif")
forest_2014_project = terra::rast("./data/LULC/forest_2014_project.tif")

forest_2019_gola = terra::rast("./data/LULC/forest_2019_gola.tif")
forest_2019_tong = terra::rast("./data/LULC/forest_2019_tong.tif")
forest_2019_norm = terra::rast("./data/LULC/forest_2019_norm.tif")
forest_2019_project = terra::rast("./data/LULC/forest_2019_project.tif")

forest_2024_gola = terra::rast("./data/LULC/forest_2024_gola.tif")
forest_2024_tong = terra::rast("./data/LULC/forest_2024_tong.tif")
forest_2024_norm = terra::rast("./data/LULC/forest_2024_norm.tif")
forest_2024_project = terra::rast("./data/LULC/forest_2024_project.tif")

forest_loss_2014_2019_gola = terra::rast( "./data/LULC/forest_loss_2014_2019_gola.tif")
forest_loss_2014_2019_tong = terra::rast( "./data/LULC/forest_loss_2014_2019_tong.tif")
forest_loss_2014_2019_norm = terra::rast( "./data/LULC/forest_loss_2014_2019_norm.tif")
forest_loss_2014_2019_project = terra::rast( "./data/LULC/forest_loss_2014_2019_project.tif")

forest_loss_2019_2024_gola = terra::rast( "./data/LULC/forest_loss_2019_2024_gola.tif")
forest_loss_2019_2024_tong = terra::rast( "./data/LULC/forest_loss_2019_2024_tong.tif")
forest_loss_2019_2024_norm = terra::rast( "./data/LULC/forest_loss_2019_2024_norm.tif")
forest_loss_2019_2024_project = terra::rast("./data/LULC/forest_loss_2019_2024_project.tif")

forest_loss_2014_2024_gola = terra::rast("./data/LULC/forest_loss_2014_2024_gola.tif")
forest_loss_2014_2024_tong = terra::rast("./data/LULC/forest_loss_2014_2024_tong.tif")
forest_loss_2014_2024_norm = terra::rast("./data/LULC/forest_loss_2014_2024_norm.tif")
forest_loss_2014_2024_project = terra::rast("./data/LULC/forest_loss_2014_2024_project.tif")

# reproject back to metric estimates
forest_2014 <- terra::project(forest_2014, "EPSG:32629")
forest_2019 <- terra::project(forest_2019, "EPSG:32629")
forest_2024 <- terra::project(forest_2024, "EPSG:32629")
forest_loss_2014_2019 <- terra::project(forest_loss_2014_2019, "EPSG:32629")
forest_loss_2019_2024 <- terra::project(forest_loss_2019_2024, "EPSG:32629")
forest_loss_2014_2024 <- terra::project(forest_loss_2014_2024, "EPSG:32629")

forest_2014_gola <- terra::project(forest_2014_gola, "EPSG:32629")
forest_2014_tong <- terra::project(forest_2014_tong, "EPSG:32629")
forest_2014_norm <- terra::project(forest_2014_norm, "EPSG:32629")
forest_2014_project <- terra::project(forest_2014_project, "EPSG:32629")
forest_2019_gola <- terra::project(forest_2019_gola, "EPSG:32629")
forest_2019_tong <- terra::project(forest_2019_tong, "EPSG:32629")
forest_2019_norm <- terra::project(forest_2019_norm, "EPSG:32629")
forest_2019_project <- terra::project(forest_2019_project, "EPSG:32629")
forest_2024_gola <- terra::project(forest_2024_gola, "EPSG:32629")
forest_2024_tong <- terra::project(forest_2024_tong, "EPSG:32629")
forest_2024_norm <- terra::project(forest_2024_norm, "EPSG:32629")
forest_2024_project <- terra::project(forest_2024_project, "EPSG:32629")

forest_loss_2014_2019_gola <- terra::project(forest_loss_2014_2019_gola, "EPSG:32629")
forest_loss_2014_2019_tong <- terra::project(forest_loss_2014_2019_tong, "EPSG:32629")
forest_loss_2014_2019_norm <- terra::project(forest_loss_2014_2019_norm, "EPSG:32629")
forest_loss_2014_2019_project <- terra::project(forest_loss_2014_2019_project, "EPSG:32629")
forest_loss_2019_2024_gola <- terra::project(forest_loss_2019_2024_gola, "EPSG:32629")
forest_loss_2019_2024_tong <- terra::project(forest_loss_2019_2024_tong, "EPSG:32629")
forest_loss_2019_2024_norm <- terra::project(forest_loss_2019_2024_norm, "EPSG:32629")
forest_loss_2019_2024_project <- terra::project(forest_loss_2019_2024_project, "EPSG:32629")
forest_loss_2014_2024_gola <- terra::project(forest_loss_2014_2024_gola, "EPSG:32629")
forest_loss_2014_2024_tong <- terra::project(forest_loss_2014_2024_tong, "EPSG:32629")
forest_loss_2014_2024_norm <- terra::project(forest_loss_2014_2024_norm, "EPSG:32629")
forest_loss_2014_2024_project <- terra::project(forest_loss_2014_2024_project, "EPSG:32629")

raster::writeRaster(forest_2014,"./data/BINARY/forest_2014.tif",overwrite=T)
raster::writeRaster(forest_2019,"./data/BINARY/forest_2019.tif",overwrite=T)
raster::writeRaster(forest_2024,"./data/BINARY/forest_2024.tif",overwrite=T)

raster::writeRaster(forest_loss_2014_2019,"./data/BINARY/forest_loss_2014_2019.tif",overwrite=T)
raster::writeRaster(forest_loss_2019_2024,"./data/BINARY/forest_loss_2019_2024.tif",overwrite=T)
raster::writeRaster(forest_loss_2014_2024,"./data/BINARY/forest_loss_2014_2024.tif",overwrite=T)
```

```{r, cache=T, eval=T}
# Calculate total number of forest pixels for each year
resolution <- res(forest_2014)[1]
forest_2014_estimate <- sum(forest_2014[], na.rm = TRUE) * resolution^2 / 10000
forest_2019_estimate <- sum(forest_2019[], na.rm = TRUE) * resolution^2 / 10000
forest_2024_estimate <- sum(forest_2024[], na.rm = TRUE) * resolution^2 / 10000
cat("Forest area in 2014:", forest_2014_estimate, "hectares\n")
cat("Forest area in 2019:", forest_2019_estimate, "hectares\n")
cat("Forest area in 2024:", forest_2024_estimate, "hectares\n")

# Calculate forest area for each sub-region (in hectares) for all years
forest_2014_gola_estimate <- sum(forest_2014_gola[], na.rm = TRUE) * resolution^2 / 10000
forest_2014_tong_estimate <- sum(forest_2014_tong[], na.rm = TRUE) * resolution^2 / 10000
forest_2014_norm_estimate <- sum(forest_2014_norm[], na.rm = TRUE) * resolution^2 / 10000
forest_2014_project_estimate <- sum(forest_2014_project[], na.rm = TRUE) * resolution^2 / 10000
forest_2019_gola_estimate <- sum(forest_2019_gola[], na.rm = TRUE) * resolution^2 / 10000
forest_2019_tong_estimate <- sum(forest_2019_tong[], na.rm = TRUE) * resolution^2 / 10000
forest_2019_norm_estimate <- sum(forest_2019_norm[], na.rm = TRUE) * resolution^2 / 10000
forest_2019_project_estimate <- sum(forest_2019_project[], na.rm = TRUE) * resolution^2 / 10000
forest_2024_gola_estimate <- sum(forest_2024_gola[], na.rm = TRUE) * resolution^2 / 10000
forest_2024_tong_estimate <- sum(forest_2024_tong[], na.rm = TRUE) * resolution^2 / 10000
forest_2024_norm_estimate <- sum(forest_2024_norm[], na.rm = TRUE) * resolution^2 / 10000
forest_2024_project_estimate <- sum(forest_2024_project[], na.rm = TRUE) * resolution^2 / 10000

# Calculate forest loss for each sub-region (in hectares) for all periods
forest_loss_2014_2019_gola_estimate<-sum(forest_loss_2014_2019_gola[],na.rm=T)*resolution^2/10000
forest_loss_2014_2019_tong_estimate <- sum(forest_loss_2014_2019_tong[],na.rm=T)*resolution^2/10000
forest_loss_2014_2019_norm_estimate <- sum(forest_loss_2014_2019_norm[],na.rm=T)*resolution^2/10000
forest_loss_2014_2019_project_estimate <- sum(forest_loss_2014_2019_project[],na.rm=T)*resolution^2/10000
forest_loss_2019_2024_gola_estimate<- sum(forest_loss_2019_2024_gola[],na.rm=T)*resolution^2/10000
forest_loss_2019_2024_tong_estimate <- sum(forest_loss_2019_2024_tong[],na.rm=T)*resolution^2/10000
forest_loss_2019_2024_norm_estimate <- sum(forest_loss_2019_2024_norm[],na.rm=T)*resolution^2/10000
forest_loss_2019_2024_project_estimate <- sum(forest_loss_2019_2024_project[],na.rm=T)*resolution^2/10000
forest_loss_2014_2024_gola_estimate <- sum(forest_loss_2014_2024_gola[],na.rm=T)*resolution^2/10000
forest_loss_2014_2024_tong_estimate <- sum(forest_loss_2014_2024_tong[],na.rm=T)*resolution^2/10000
forest_loss_2014_2024_norm_estimate <- sum(forest_loss_2014_2024_norm[],na.rm=T)*resolution^2/10000
forest_loss_2014_2024_project_estimate <- sum(forest_loss_2014_2024_project[],na.rm=T)*resolution^2/10000

# Print out the forest area and loss estimates for each region and year
cat("Forest Area in Gola NP (2014):", forest_2014_gola_estimate, "hectares\n")
cat("Forest Area in Tonglay (2014):", forest_2014_norm_estimate, "hectares\n")
cat("Forest Area in Norman (2014):", forest_2014_tong_estimate, "hectares\n")
cat("Forest Area in Project (2014):", forest_2014_project_estimate, "hectares\n")
cat("Forest Area in Gola NP (2019):", forest_2019_gola_estimate, "hectares\n")
cat("Forest Area in Tonglay (2019):", forest_2019_tong_estimate, "hectares\n")
cat("Forest Area in Norman (2019):", forest_2019_norm_estimate, "hectares\n")
cat("Forest Area in Project (2019):", forest_2019_project_estimate, "hectares\n")
cat("Forest Area in Gola NP (2024):", forest_2024_gola_estimate, "hectares\n")
cat("Forest Area in Tonglay (2024):", forest_2024_tong_estimate, "hectares\n")
cat("Forest Area in Norman (2024):", forest_2024_norm_estimate, "hectares\n")
cat("Forest Area in Project (2024):", forest_2024_project_estimate, "hectares\n")

cat("Forest Loss in Gola NP (2014-2019):", forest_loss_2014_2019_gola_estimate, "hectares\n")
cat("Forest Loss in Tonglay (2014-2019):", forest_loss_2014_2019_tong_estimate, "hectares\n")
cat("Forest Loss in Norman (2014-2019):", forest_loss_2014_2019_norm_estimate, "hectares\n")
cat("Forest Loss in Project (2014-2019):", forest_loss_2014_2019_project_estimate, "hectares\n")
cat("Forest Loss in Gola NP (2019-2024):", forest_loss_2019_2024_gola_estimate, "hectares\n")
cat("Forest Loss in Tonglay (2019-2024):", forest_loss_2019_2024_tong_estimate, "hectares\n")
cat("Forest Loss in Norman (2019-2024):", forest_loss_2019_2024_norm_estimate, "hectares\n")
cat("Forest Loss in Project (2019-2024):", forest_loss_2019_2024_project_estimate, "hectares\n")
cat("Forest Loss in Gola NP (2014-2024):", forest_loss_2014_2024_gola_estimate, "hectares\n")
cat("Forest Loss in Tonglay (2014-2024):", forest_loss_2014_2024_tong_estimate, "hectares\n")
cat("Forest Loss in Norman (2014-2024):", forest_loss_2014_2024_norm_estimate, "hectares\n")
cat("Forest Loss in Project (2014-2024):", forest_loss_2014_2024_project_estimate, "hectares\n")
```

### Forest risk mapping & deforestation allocation

The following spatial covariates were imported and processed as potential drivers of deforestation risk. These covariates were merged from sociodemographic and geographic datasets surrounding the project area that were derived and vetted by the Winrock GIS team, along with additional national level datasets to enable regional anlaysis across jurisdictions. In preparation for upcoming collaborations with RSPB contractors and to ensure replicability in all Winrock workflows, the team shared below key links to the main data warehouses consulted in the following operations.

The Winrock team wishes to advise that further updates are expected to these spatial coveriates pending delivery of proprietary data from the client. We also recommend that these mapping and risk assessments should be heavily revised or replaced prior to submission of PD to Verra, especially following the release of Liberia's Activity Data and jurisdictional deforestation risk maps [planned by Verra in Q3 of 2025](https://verra.org/methodologies-main/allocated-deforestation-risk-maps-timetable).

#### *Sociodemographic & topographic covariates*

```{r, eval=F, cache=T}
# Download  EU & OSM data
pop_url <- "https://jeodpp.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL/GHS_POP_GLOBE_R2023A/GHS_POP_E2025_GLOBE_R2023A_54009_1000/V1-0/GHS_POP_E2025_GLOBE_R2023A_54009_1000_V1_0.zip" 
osm_url <- "https://download.geofabrik.de/africa/liberia-latest-free.shp.zip" 

##############################
##### Covariate wrangling#####
##############################

##### Built Environment
places_points_project=sf::st_read("./data/Winrock_GIS/Communities_8km.shp")|>
  st_cast("POINT")|>dplyr::select(name,fclass)|>rename(place=fclass)|>
  mutate(place = as.factor(place)) |> mutate(name = as.character(name))

places_points_liberia_1=sf::st_read("./data/liberia-osmdata/liberia_point.shp")|>
  st_cast("POINT")|>sf::st_intersection(country)|>
  dplyr::select(name,place)|>
  dplyr::mutate(place = as.factor(place)) |> 
  dplyr::mutate(name = as.character(name))

places_points_liberia_2 <- sf::st_read("./data/liberia-osmdata/gis_osm_places_free_1.shp")|>
  st_cast("POINT")|>sf::st_intersection(country)|>
  dplyr::select(name,fclass)|>
  dplyr::rename(place=fclass)|>
  dplyr::mutate(place = as.factor(place))|> 
  dplyr::mutate(name = as.character(name))

places_worship <- sf::st_read("./data/liberia-osmdata/gis_osm_pofw_free_1.shp") |>
  sf::st_intersection(country)|>
  dplyr::select(name,fclass)|>
  dplyr::rename(creed=fclass) |> 
  dplyr::mutate(creed=as.factor(creed))  |> 
  dplyr::mutate(name = as.character(name)) |> 
  st_cast("POINT")

places_points <- places_points_project %>%
  bind_rows(places_points_liberia_1,places_points_liberia_2, places_worship) %>%
  group_by(across(-geometry)) %>%
  summarise(geometry = st_union(geometry), .groups = "drop")
places_points = sf::st_cast(places_points, "POINT")
sf::st_write(places_points, "./data/covariates/places_points.shp", delete_dsn=T)

##### Administrative Boundaries
places_poly_liberia <- sf::st_read("./data/liberia-osmdata/liberia_poly.shp")|>st_cast("GEOMETRY")
places_poly_county <- places_poly_liberia[st_geometry_type(places_poly_liberia) %in% c("POLYGON", "MULTIPOLYGON"), ] |>
  sf::st_intersection(country)|>
  dplyr::select(name,place,admin_leve)|>
  dplyr::mutate(place = as.factor(place)) |> 
  dplyr::mutate(name = as.character(name)) |>
  dplyr::rename(admin_level = admin_leve) |>
  dplyr::filter(admin_level == "4") 
places_poly_county <- places_poly_county[st_geometry_type(places_poly_county) %in% c("POLYGON", "MULTIPOLYGON"), ] |>
  sf::st_cast("MULTIPOLYGON")
sf::st_write(places_poly_county, "./data/covariates/places_poly_county.shp", delete_dsn=T)  

places_poly_district <- places_poly_liberia[st_geometry_type(places_poly_liberia) %in% c("POLYGON", "MULTIPOLYGON"), ] |>
  st_cast("POLYGON")|>sf::st_intersection(country)|>
  dplyr::select(name,place,admin_leve)|>
  dplyr::mutate(place = as.factor(place)) |> 
  dplyr::mutate(name = as.character(name)) |>
  dplyr::rename(admin_level = admin_leve) |>
  dplyr::filter(admin_level == "6")
places_poly_district <- places_poly_district[st_geometry_type(places_poly_district) %in% c("POLYGON", "MULTIPOLYGON"), ] |>
  sf::st_cast("MULTIPOLYGON")
sf::st_write(places_poly_district, "./data/covariates/places_poly_district.shp", delete_dsn=T)  

buildings_private <- sf::st_read("./data/liberia-osmdata/gis_osm_buildings_a_free_1.shp") |> 
  sf::st_intersection(country) |> sf::st_simplify(preserveTopology = FALSE, dTolerance = 1000) |>
  dplyr::select(name,fclass) |>
  dplyr::rename(place = fclass) |> 
  dplyr::mutate(place = as.factor(place))|> 
  dplyr::mutate(name = as.character(name)) |>
  st_cast("MULTIPOLYGON") 
sf::st_write(buildings_private, "./data/covariates/buildings_private.shp", delete_dsn=T)

buildings_public <- sf::st_read("./data/liberia-osmdata/gis_osm_pois_a_free_1.shp")  |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::rename(place = fclass) |> 
  dplyr::mutate(place = as.factor(place))|> 
  dplyr::mutate(name = as.character(name)) |>
  st_cast("MULTIPOLYGON") 
sf::st_write(buildings_public, "./data/covariates/buildings_public.shp", delete_dsn=T)

buildings_merged <- buildings_private |> bind_rows(buildings_public) |>
  group_by(across(-geometry)) |> summarise(geometry = st_union(geometry), .groups = "drop")
buildings_merged = sf::st_cast(buildings_merged, "POLYGON")
sf::st_write(buildings_merged, "./data/covariates/buildings.shp", delete_dsn=T)


###### Waterways 
waterways_liberia = sf::st_read("./data/liberia-osmdata/gis_osm_waterways_free_1.shp") |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))
waterways_liberia <- waterways_liberia[st_geometry_type(waterways_liberia) %in% c("LINESTRING", "MULTILINESTRING"), ] |>
  st_cast("MULTILINESTRING") 

waterways_project = sf::st_read("./data/Winrock_GIS/PA_river.shp") |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))
waterways_project <- waterways_project[st_geometry_type(waterways_project) %in% c("LINESTRING", "MULTILINESTRING"), ] |>
  st_cast("MULTILINESTRING") 

waterways_merged <- waterways_liberia |> bind_rows(waterways_project) |>
  group_by(across(-geometry)) |> summarise(geometry = st_union(geometry), .groups = "drop")
waterways_merged = sf::st_cast(waterways_merged, "MULTILINESTRING")
sf::st_write(waterways_merged, "./data/covariates/waterways_merged.shp", delete_dsn=T)

waterbodies_collection = sf::st_read("./data/liberia-osmdata/gis_osm_water_a_free_1.shp") |> 
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))
waterbodies_poly <- waterbodies_collection[st_geometry_type(waterbodies_collection) %in% c("POLYGON", "MULTIPOLYGON"), ] 
waterbodies_lines <- waterbodies_collection[st_geometry_type(waterbodies_collection) %in% c("LINESTRING", "MULTILINESTRING"), ] 
waterbodies_poly_lines = sf::st_boundary(waterbodies_poly)

waterbodies_waterways_merged <- waterbodies_lines |> bind_rows(waterbodies_poly_lines, waterways_merged) |>
  group_by(across(-geometry)) |> summarise(geometry = st_union(geometry), .groups = "drop")
waterbodies_waterways_merged = sf::st_cast(waterbodies_waterways_merged, "MULTILINESTRING")
sf::st_write(waterbodies_merged, "./data/covariates/waterbodies_waterways_merged.shp", delete_dsn=T)


###### Transport & Infrastructure
transport = sf::st_read("./data/liberia-osmdata/gis_osm_transport_a_free_1.shp") |> sf::st_boundary() |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))

railways = sf::st_read("./data/liberia-osmdata/gis_osm_railways_free_1.shp") |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))

roads_liberia = sf::st_read("./data/liberia-osmdata/gis_osm_roads_free_1.shp") |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))

roads_project = sf::st_read("./data/Winrock_GIS/PA_roads.shp") |>
  sf::st_intersection(country) |>
  dplyr::select(name,fclass) |>
  dplyr::mutate(fclass = as.factor(fclass))|> 
  dplyr::mutate(name = as.character(name))

roads_rail_transport_merged <- transport |> bind_rows(railways, roads_liberia, roads_project) |>
  group_by(across(-geometry)) |> summarise(geometry = st_union(geometry), .groups = "drop")
roads_rail_transport_merged = sf::st_cast(roads_rail_transport_merged, "MULTILINESTRING")
sf::st_write(roads_rail_transport_merged, "./data/covariates/roads_rail_transport_merged.shp", delete_dsn=T)

##### Slope / Elevation
dem   = raster::subset(STACK, "DEM")
slope_tangent = raster::terrain(
  dem, opt="slope",unit="tangent",neighbors=8,filename="./data/DEM/slope_tangent.tif")
slope_tangent = terra::rast("./data/DEM/slope_tangent.tif")
slope_percent = slope_tangent * 100
slope_percent = terra::clamp(slope_percent, 0, 100) 
slope_percent = raster::raster(slope_percent)
raster::writeRaster(slope_percent, "./data/covariates/slope_percent.tif")

urban <- terra::mask(LULC_LIBERIA_2024, LULC_LIBERIA_2024 == 4, maskvalue = FALSE)
urban <- raster::raster(urban)
raster::writeRaster(urban, "./data/covariates/urban.tif", overwrite=T)
```

```{r, eval=F, echo=F}
#### assemble covariates & response
deforestation = stars::read_stars("./data/LULC/forest_loss_2014_2024.tif") # UPDATE with annualized raster
population    = stars::read_stars("./data/covariates/liberia_population.tif")
slope         = stars::read_stars("./data/covariates/slope_percent.tif")
urban         = stars::read_stars("./data/covariates/urban.tif")

counties      = sf::st_read("./data/covariates/places_poly_county.shp")
districts     = sf::st_read("./data/covariates/places_poly_district.shp")
places        = sf::st_read("./data/covariates/places_points.shp")
transport     = sf::st_read("./data/covariates/roads_rail_transport_merged.shp")
waterways     = sf::st_read("./data/covariates/waterbodies_waterways_merged.shp")
buildings     = sf::st_read("./data/covariates/buildings_merged.shp")
waterpoly     = sf::st_read("./data/liberia_osmdata/waterpoly_valid.shp") 

tmap::tmap_mode("view")
tmap::tm_shape(country) + tmap::tm_borders(lwd = 2, col="black") +
  tmap::tm_shape(transport) + tmap::tm_lines(col = "orange", lwd=0.9) +
  tmap::tm_add_legend(type="line", col="orange", labels = "Roads/Rail") +
  tmap::tm_shape(places) +
  tmap::tm_dots(col="place", palette=cols4all::c4a("misc.okabe"), id="name", size = 0.001, shape=19, legend.show=T) +
  tmap::tm_shape(counties) + tmap::tm_borders(lwd = 0.8, col="darkgreen") +
  tmap::tm_text("name", just = "center", col="black", size=0.9) +
  tmap::tm_shape(waterways) + tmap::tm_lines(col = "dodgerblue3") +
  tmap::tm_add_legend(type="line", col="dodgerblue3", labels = "Waterways") +
  tmap::tm_shape(waterpoly) + tmap::tm_fill(col = "blue") +
  tmap::tm_shape(aoi) + tmap::tm_borders(lwd = 1.2, col = "red") +
  tmap::tm_text("NAME", just = "left", col="red", size=1) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position=c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_basemap("Esri.WorldImagery") -> tm88
tm88

tmap::tm_shape(country) + tmap::tm_borders(lwd = 0) +
  tmap::tm_shape(population) +
  tmap::tm_raster(
    style   = "fixed",
    alpha   = 1,
    palette = cols4all::c4a("seq", "OrRd"),
    title   = "People/sqkm",
    breaks  = c(0, 0.01, 10, 100, 200, 1000, 2000, 20000)) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position=c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) -> tm3

tmap::tm_shape(slope) +
  tmap::tm_raster("slope_percent.tif",style="fixed",breaks=c(0, 5, 15, 20, 30, 50, 100), title   = "Slope %") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position=c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) -> tm4

tmap::tm_shape(deforestation) +
  tmap::tm_raster("forest_loss_2014_2024.tif", title   = "Forest Loss") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position=c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) -> tm5

tmap::tm_shape(urban) +
  tmap::tm_raster("urban.tif",title   = "Urban Areas") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position=c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) -> tm6

tmap::tmap_save(tm3, "./data/site_maps/population_map.png", height=10000, asp=0, dpi=1200)
tmap::tmap_save(tm4, "./data/site_maps/slope_map.png", height=10000, asp=0, dpi=1200)
tmap::tmap_save(tm5, "./data/site_maps/deforesation_map.png", height=10000, asp=0, dpi=1200)
tmap::tmap_save(tm6, "./data/site_maps/urban_map.png", height=10000, asp=0, dpi=1200)
tmap::tmap_save(tm88, "./data/site_maps/covariates_map.png", height=20000, asp=0, dpi=1200)

tmap::tmap_mode("plot")
tmap::tmap_arrange(tm3, tm4, tm6, tm5, ncols=2)
```

```{r, message=F, warning=F, error=F, comment=NA, cache=T, eval=T, echo=F}
population    = stars::read_stars("./data/covariates/liberia_population.tif")
slope         = stars::read_stars("./data/covariates/slope_percent.tif")
urban         = stars::read_stars("./data/covariates/urban.tif")

counties      = sf::st_read("./data/covariates/places_poly_county.shp")
districts     = sf::st_read("./data/covariates/places_poly_district.shp")
places        = sf::st_read("./data/covariates/places_points.shp")
transport     = sf::st_read("./data/covariates/roads_rail_transport_merged.shp")
waterways     = sf::st_read("./data/covariates/waterbodies_waterways_merged.shp")
buildings     = sf::st_read("./data/covariates/buildings_merged.shp")
waterpoly     = sf::st_read("./data/liberia_osmdata/waterpoly_valid.shp") 

tmap::tmap_mode("view")
tmap::tm_shape(country) + tmap::tm_borders(lwd = 2, col="black") +
  tmap::tm_shape(transport) + tmap::tm_lines(col = "orange", lwd=0.9, legend.show=T) +
  tmap::tm_shape(places)+tmap::tm_dots(col="place",id="name",size=0.01,shape=19,legend.show=T)+
  tmap::tm_shape(counties) + tmap::tm_borders(lwd = 0.8, col="darkgreen") +
  tmap::tm_text("name", just = "center", col="white", size=1) +
  tmap::tm_shape(waterways) + tmap::tm_lines(col = "dodgerblue3") +
  tmap::tm_add_legend(type="line", col="dodgerblue3", labels = "Waterways") +
  tmap::tm_shape(waterpoly) + tmap::tm_fill(col = "blue") +
  tmap::tm_shape(aoi) + tmap::tm_borders(lwd = 2, col = "red") +
  tmap::tm_text("NAME", just = "left", col="darkred", size=1.5) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_credits("EPSG:4326", position = c("left", "bottom")) +
  tmap::tm_scale_bar(position=c("RIGHT", "BOTTOM"), text.size = .5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_basemap("Esri.WorldImagery")
```

```{r, message=F, warning=F, error=F, comment=NA, cache=T, fig.show='hold', out.width="50%", eval=T, echo=F}
knitr::include_graphics(c("./data/site_maps/population_map.png",
                          "./data/site_maps/slope_map.png",
                          "./data/site_maps/urban_map.png",
                          "./data/site_maps/deforesation_map.png"))
```

#### *Annual forest loss*

```{r, eval=F}
# Assign zones
zones_sf = counties |> sf::st_transform("EPSG:32629")
zones_sf$zone_id <- 1:nrow(zones_sf)
zones_sv <- terra::vect(zones_sf)

# Calculate zonal annualization by jurisdiction
forest_2024 = terra::rast("./data/BINARY/forest_2024.tif")
forest_loss_2014_2019 = terra::rast("./data/BINARY/forest_loss_2014_2019.tif")
forest_loss_2019_2024 = terra::rast("./data/BINARY/forest_loss_2019_2024.tif")
forest_loss_2014_2024 = terra::rast("./data/BINARY/forest_loss_2014_2024.tif")

zonal_2014_2019 <- terra::extract(forest_loss_2014_2019,zones_sv,fun=sum,na.rm=T)
zonal_2019_2024 <- terra::extract(forest_loss_2019_2024,zones_sv,fun=sum,na.rm=T)
names(zonal_2014_2019) <- c("zone_id", "loss_2014_2019")
names(zonal_2019_2024) <- c("zone_id", "loss_2019_2024")

# Merge baseline years
zonal_stats <- merge(
  zonal_2014_2019,      # e.g. (zone_id, loss_2014_2019)
  zonal_2019_2024,      # e.g. (zone_id, loss_2019_2024)
  by = "zone_id",       # Common ID column
  all = TRUE            # Keep all rows if zones differ
)
# Annualize 10-year total & rejoin to sf object
zonal_stats$loss_10yr <- zonal_stats$loss_2014_2019 + zonal_stats$loss_2019_2024
zonal_stats$annual_loss_10yr <- zonal_stats$loss_10yr / 10
zones_sf <- merge(zones_sf, zonal_stats, by="zone_id", all.x=TRUE)
head(zones_sf[, c("zone_id", "loss_2014_2019", "loss_2019_2024", 
                  "loss_10yr", "annual_loss_10yr")])

# Derive 10-yr annualized raster
zones_sv <- terra::vect(zones_sf)
annual_loss_10yr_raster <- rasterize(
  zones_sv,                  # polygon SpatVector
  forest_loss_2014_2019,     # template raster for resolution/extent
  field = "annual_loss_10yr") # the column to rasterize
raster::writeRaster(annual_loss_10yr_raster,"./data/LULC/annual_loss_2014_2024_zonal.tif",overwrite=T)
```

#### *Distance covariates*

```{r, eval=F}
# Derive distance-to-edge raster 
forest_2024 = terra::rast("./data/BINARY/forest_2024.tif")
crs_master  = terra::crs(forest_2024)

forest_canopy <- subst(forest_2024, from = 0, to = NA)
dist_to_forest   <- distance(forest_canopy)
writeRaster(forest_canopy, "./data/BINARY/forest_canopy.tif", overwrite=T)
writeRaster(dist_to_forest, "./data/BINARY/distance_to_forest.tif", overwrite=T)

# Derive distance-to-feature rasters
template <- forest_2024
roads_rast <- rasterize(vect(transport), template, field=1, background=0)
roads_rast <- subst(roads_rast, from=0, to=NA)
distance_to_roads <- distance(roads_rast)
writeRaster(distance_to_roads, "./data/LULC/distance_to_roads.tif", overwrite=T)

places_vect   <- sf::st_read("./data/BINARY/places.shp") |> terra::vect()
places_rast   <- rasterize(places_vect,template,field=1,background=0,touches=T)
places_rast   <- subst(places_rast, from=0, to=NA)
distance_to_places<- distance(places_rast)
writeRaster(distance_to_places, "./data/LULC/distance_to_places.tif", overwrite=T)

waterways_rast<-rasterize(vect(waterways_rast), template, field=1, background=0)
waterways_rast<-subst(waterways_rast, from=0, to=NA)
distance_to_waterways<-distance(waterways_rast)
writeRaster(distance_to_waterways, "./data/LULC/distance_to_waterways.tif", overwrite=T)

urban_rast    <- raster::raster(urban)
urban_rast    <- subst(urban_rast, from=0, to=NA)
distance_to_urban <- distance(urban_rast)
writeRaster(distance_to_urban, "./data/LULC/distance_to_urban.tif", overwrite=T)

# Normalize covariates for quicker computing
normalize <- function(x){
  (x-global(x,"min",na.rm=T))/
    (global(x,"max",na.rm=T) -
       global(x, "min",na.rm=T))}

population= raster::raster(population)
population= normalize_function(population)
slope     = raster::raster(slope)
slope     = normalize_function(slope)

distance_to_forest    = normalize_function(distance_to_forest)
distance_to_roads     = normalize_function(distance_to_roads)
distance_to_places    = normalize_function(distance_to_places)
distance_to_waterways = normalize_function(distance_to_waterways)
distance_to_urban     = normalize_function(distance_to_urban)

# invert edge & slope for higher proximity risk & inverse correlations
distance_to_edge  <- 1 - distance_to_forest
slope_inv <- 1 - slope

writeRaster(distance_to_edge, "./data/BINARY/distance_to_edge.tif", overwrite=T)
writeRaster(slope_inv, "./data/BINARY/slope_inv.tif", overwrite=T)
```

```{r, echo=F, cache=T, fig.show='hold', out.width="30%"}
deforestation      <- terra::rast("./data/LULC/annual_loss_2014_2024_zonal.tif") |> 
distance_to_edge   <- terra::rast("./data/BINARY/distance_to_edge.tif")
distance_to_places <- terra::rast("./data/BINARY/distance_to_places.tif")
distance_to_roads  <- terra::rast("./data/BINARY/distance_to_roads.tif")
distance_to_urban  <- terra::rast("./data/BINARY/distance_to_urban.tif")
distance_to_water  <- terra::rast("./data/BINARY/distance_to_water.tif")
population         <- terra::rast("./data/BINARY/population.tif")
slope              <- terra::rast("./data/BINARY/slope_inv.tif")


terra::plot(distance_to_edge)
terra::plot(distance_to_places)
terra::plot(distance_to_roads)
terra::plot(distance_to_urban)
terra::plot(distance_to_water)
terra::plot(population)
terra::plot(slope)
```

#### *Deforestation risk & allocation*

Two methods were explored for weighting variables and creating a generalized deforestation risk index. We could consider developing a spatial risk model using the `spatstat` package or logistic regression, as has been cited in recent Verra guides. In addition, some of the heavy lifting with input formatting and data wrangling has already been completed.

However, spatial modelling has tended to produce challenges when fitting such large country-wide covariates. Moreover, these kinds of spatialy driven models tend to require longer training procedures due to their intercept-based spatial kernels and slower resampling patterns.

Alternatively, we have drafted a tentative risk indexing approach based on a weighted sum of subjectively scored covariate effects. While each variable would still need a carefully reasoned score, this option offers a more streamlined method that is easier to adjust. We applied this risk index to inform a risk weighted allocation of the 10-year deforestation rate, first by multiplying the fraction of pixel risk by zonal forest loss, and second by factoring out annual zonal loss by multiplying by pixel risk values, as shown below:

$$
\mathrm{AllocatedLoss}_{\mathrm{pixel}}
=
\left(
  \frac{\mathrm{risk}_{\mathrm{pixel}}}{\sum \mathrm{risk}_{\mathrm{zone}}}
\right)
\times
\mathrm{annual\_loss\_10yr}_{\mathrm{zone}}
$$ $$
\mathrm{allocated\_loss}_{\mathrm{pixel}}
=
\mathrm{risk}_{\mathrm{pixel}}
\times
\left(
  \frac{\mathrm{annual\_loss\_10yr}_{\mathrm{zone}}}{\sum \mathrm{risk}_{\mathrm{zone}}}
\right)
$$ Both formulas describe the same operation in different orders of multiplication: each pixel in a given zone Z receives a share of annual_loss_10yr~Z~ based on its proportional risk (the pixels risk relative to the sum of all pixel risks in that zone). This ensures that higher-risk pixels are allocated more deforestation, in line with the Verra guidance for an allocated deforestation risk map.

We intend to present both of these approaches for broader review and discussion in our upcoming meeting.

```{r}
risk_index <- (0.2 * distance_to_edge) +
              (0.2 * distance_to_roads) +
              (0.1 * distance_to_places) +
              (0.1 * distance_to_urban) +
              (0.1 * distance_to_water) +
              (0.2 * population) +
              (0.1 * slope)

# Re-normalize the index to between 0 and 1
rmin <- global(risk_index, "min", na.rm=TRUE)[1]
rmax <- global(risk_index, "max", na.rm=TRUE)[1]
risk_index_norm <- (risk_index - rmin) / (rmax - rmin)
writeRaster(risk_index_norm, "./data/LULC/deforestation_risk_index.tif",overwrite=T)

# Returns a data.frame with columns: ID, risk_index_norm_sum
risk_sum <- extract(risk_index_norm, zones_sv, fun = sum, na.rm=TRUE)
colnames(risk_sum) <- c("zone_id","sum_risk")
zones_stats <- merge(zones_sf, risk_sum, by="zone_id", all.x=TRUE)
zones_rast <- rasterize(vect(zones_stats), risk_index_norm, field="zone_id")
zones_stats$loss_factor <- zones_stats$annual_loss_10yr / zones_stats$sum_risk
loss_factor_rast <- rasterize(vect(zones_stats), risk_index_norm, field="loss_factor")
allocated_loss <- risk_index_norm * loss_factor_rast
writeRaster(allocated_loss, "allocated_deforestation.tif", overwrite=TRUE)
```

### Appendix

***2019 and 2024 classifiers***

To run these, you may change eval=F to eval=T at the top of chunk in the .Rmd or .R file saved in the OneDrive folder.

```{r, eval=F, echo=T}
########################### 2019
# extract signatures
signatures_2019 = raster::extract(STACK_2019, samples ,df=T) # watch for data formats
samples_signatures_2019 <- dplyr::inner_join(signatures_2019, samples, by=c("ID"="id"))
samples_signatures_2019$geometry <- NULL # set geometry to NULL for model training

# training-test split, p=0.7 -> 70% split
trainIndex_2019 <- caret::createDataPartition(samples_signatures_2019$ID,list=F,p=0.7)
trainData_2019  <- samples_signatures_2019[trainIndex_2019,]  
testData_2019   <- samples_signatures_2019[-trainIndex_2019,] 

# interpolate NAs with class-median-normalization (NAs -> missing cloud pixels)
trainData_2019 <- trainData_2019 |> group_by(label) |> mutate(across(where(is.numeric),
    ~ ifelse(is.na(.), median(., na.rm = TRUE), .))) |> ungroup()
testData_2019 <- testData_2019 |> group_by(label) |> mutate(across(where(is.numeric),
    ~ ifelse(is.na(.), median(., na.rm = TRUE), .))) |> ungroup()

# assign model variables
response  <- c("label")
predictors_2019 <- c(
  "NDVI_2019", "BLUE_2019", "GREEN_2019", "RED_2019", 
  "NIR08_2019", "SWIR16_2019", "SWIR22_2019", "DEM"
  )

# train classifier
rf_model_2019 <- caret::train(
  label~.,
  data = trainData_2019[, c(predictors_2019, "label")], # drop ID var
  trControl = cv_regime,
  method    = "rf", 
  metric    = 'Kappa', 
  ntree     = 500,
  tuneLength= 6,
  importance= T
  )

rf_test_2019 <- predict(rf_model_2019, testData_2019)
print(rf_model_2019) # cv results
confusionMatrix(rf_test_2019,testData_2019$label) # blind test results

index_feature_2019 <- createMultiFolds(trainData_2019$label, times=5) 
predictor_seq_2019 <-seq(from=1, to=length(predictors_2019),by=2)

subset_regime_2019 <- rfeControl(
  method="cv",
  number = 10,
  verbose=FALSE,
  functions=rfFuncs,
  index=index_feature_2019
  )

rf_model_subset_2019 <- caret::rfe(
  label~.,
  data = trainData_2019[, c(predictors_2019, "label")], 
  sizes = predictor_seq_2019,
  metric = "Kappa",
  ntree=500,
  method="rf",
  rfeControl = subset_regime_2019
  )

rf_subset_test_2019 <- predict(rf_model_subset_2019,testData_2019)
print(rf_model_subset_2019)
confusionMatrix(rf_subset_test_2019$pred,testData_2019$label)

######################### 2024
# extract signatures
signatures_2024 = raster::extract(STACK_2024, samples ,df=T) # watch for data formats
samples_signatures_2024 <- dplyr::inner_join(signatures_2024, samples, by=c("ID"="id"))
samples_signatures_2024$geometry <- NULL # set geometry to NULL for model training

# training-test split, p=0.7 -> 70% split
trainIndex_2024 <- caret::createDataPartition(samples_signatures_2024$ID,list=F,p=0.7)
trainData_2024  <- samples_signatures_2024[trainIndex_2024,]  
testData_2024   <- samples_signatures_2024[-trainIndex_2024,] 

# interpolate NAs with class-median-normalization (NAs -> missing cloud pixels)
trainData_2024 <- trainData_2024 |> group_by(label) |> mutate(across(where(is.numeric),
    ~ ifelse(is.na(.), median(., na.rm = TRUE), .))) |> ungroup()
testData_2024 <- testData_2024 |> group_by(label) |> mutate(across(where(is.numeric),
    ~ ifelse(is.na(.), median(., na.rm = TRUE), .))) |> ungroup()
water_2014 <- trainData_2014[trainData_2014$label == "Water", ]
water_ids <- water_2014$ID
water_2024 <- samples_signatures_2024[samples_signatures_2024$ID %in% water_ids, ]
trainData_2024 <- rbind(trainData_2024, water_2024)
table(trainData_2024$label)

# assign model variables
response  <- c("label")
predictors_2024 <- c("NDVI_2024", "BLUE_2024", "GREEN_2024", "RED_2024", 
  "NIR08_2024", "SWIR16_2024", "SWIR22_2024", "DEM"
  )

# train classifier
rf_model_2024 <- caret::train(
  label~.,
  data = trainData_2024[, c(predictors_2024, "label")], # drop ID var
  trControl = cv_regime,
  method    = "rf", 
  metric    = 'Kappa', 
  ntree     = 500,
  tuneLength= 6,
  importance= T
  )

rf_test_2024 <- predict(rf_model_2024, testData_2024)
print(rf_model_2024) # cv results
confusionMatrix(rf_test_2024,testData_2024$label) # blind test results

index_feature_2024 <- createMultiFolds(trainData_2024$label, times=5) 
predictor_seq_2024 <-seq(from=1, to=length(predictors_2024),by=2)

subset_regime_2024 <- rfeControl(
  method="cv",
  number = 10,
  verbose=FALSE,
  functions=rfFuncs,
  index=index_feature_2024
  )

rf_model_subset_2024 <- caret::rfe(
  label~.,
  data = trainData_2024[, c(predictors_2024, "label")], 
  sizes = predictor_seq_2024,
  metric = "Kappa",
  ntree=500,
  method="rf",
  rfeControl = subset_regime_2024
  )

rf_subset_test_2024 <- predict(rf_model_subset_2024,testData_2024)
print(rf_model_subset_2024)
confusionMatrix(rf_subset_test_2024$pred,testData_2024$label)
```

```{r, eval=F}
LULC_LIBERIA_2019 <- raster::predict(STACK_2019,rf_model_2019) 
raster::writeRaster(LULC_LIBERIA_2019,"./data/LULC/LULC_LIBERIA_2019-01-02.tif",
  format = "GTiff",overwrite = T)

LULC_LIBERIA_2024 <- raster::predict(STACK_2024,rf_model_2024) 
raster::writeRaster(LULC_LIBERIA_2024,"./data/LULC/LULC_LIBERIA_2024-01-16.tif",
  format = "GTiff",overwrite = T)
```

```{r}
devtools::session_info()
```
